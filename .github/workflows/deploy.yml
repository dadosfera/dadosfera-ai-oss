name: Deploy
on:
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to deploy"
        required: true
        default: "beta"
        type: string
  push:
    branches:
      - main
      - beta

jobs:
  extract_environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.extract_environment.outputs.environment }}
    steps:
      - name: Extract Environment
        run: |
          if [ ${GITHUB_REF} == "refs/heads/main" ]; then
            echo "environment=prd" >> $GITHUB_OUTPUT
          elif [ ${GITHUB_REF} == "refs/heads/beta" ]; then
            echo "environment=stg" >> $GITHUB_OUTPUT
          fi
        id: extract_environment

  calver_release:
    runs-on: ubuntu-latest
    if: ${{ (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/oracle-compatibility')) || github.event_name == 'workflow_dispatch' }}
    outputs:
      new_release_published: ${{ steps.create_release.outputs.url != '' }}
      new_release_version: ${{ steps.get_version.outputs.tag_name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: CalVer
        id: calver
        uses: energostack/calver-action@v1
        with:
          date_format: '%Y.%m.%-d'
          prerelease: false

      - name: Get Version
        id: get_version
        env:
          WORKFLOW_DISPATCH: ${{ github.event_name == 'workflow_dispatch' }}
          BETA_BRANCH: ${{ github.ref == 'refs/heads/oracle-compatibility' }}
          REF: ${{ github.ref }}
          NEXT_VERSION: ${{ steps.calver.outputs.next_version }}
        run: |
          if [ "${WORKFLOW_DISPATCH}" == "true" ] || [ "${BETA_BRANCH}" == "true" ]; then
            BRANCH_NAME=$(echo "${REF}" | sed 's|refs/heads/||')
            echo "tag_name=${NEXT_VERSION}.${BRANCH_NAME}" >> $GITHUB_OUTPUT
          else
            echo "tag_name=${NEXT_VERSION}" >> $GITHUB_OUTPUT
          fi

      - name: Create Release
        uses: softprops/action-gh-release@v1
        id: create_release
        with:
          tag_name: ${{ steps.get_version.outputs.tag_name }}
          generate_release_notes: true
          prerelease: ${{ github.event_name == 'workflow_dispatch' }} || ${{ github.ref == 'refs/heads/oracle-compatibility' }}

  deploy_webserver:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: orchest-webserver
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: services/orchest-webserver
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          cp -r lib/ $BUILD_CTX
          cp -r orchest-sdk/ $BUILD_CTX
          mkdir -p $BUILD_CTX/pnpm_files/
          cp pnpm-lock.yaml $BUILD_CTX/pnpm_files/
          cp pnpm-workspace.yaml $BUILD_CTX/pnpm_files/
          cp package.json $BUILD_CTX/pnpm_files/
          cp tsconfig.json $BUILD_CTX/pnpm_files/
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df

  deploy_auth_server:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: auth-server
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: services/auth-server/
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          cp -r lib/ $BUILD_CTX
          cp -r orchest-sdk/ $BUILD_CTX
          mkdir -p $BUILD_CTX/pnpm_files/
          cp pnpm-lock.yaml $BUILD_CTX/pnpm_files/
          cp pnpm-workspace.yaml $BUILD_CTX/pnpm_files/
          cp package.json $BUILD_CTX/pnpm_files/
          cp tsconfig.json $BUILD_CTX/pnpm_files/
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df


  deploy_api:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: orchest-api
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: services/orchest-api
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          cp -r lib/ $BUILD_CTX
          cp -r orchest-sdk/ $BUILD_CTX
          cp -r orchest-cli/ $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df

  deploy_celery:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: celery-worker
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: services/orchest-api
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          cp -r lib/ $BUILD_CTX
          cp -r orchest-sdk/ $BUILD_CTX
          cp -r orchest-cli/ $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/Dockerfile_celery $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

  deploy_node_agent:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: node-agent
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: services/node-agent
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          cp -r lib/ $BUILD_CTX
          cp -r orchest-sdk/ $BUILD_CTX
          cp -r orchest-cli/ $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df

  deploy_orchest_controller:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: orchest-controller
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: services/orchest-controller
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df

  deploy_jupyter_server:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: jupyter-server
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: services/jupyter-server
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          cp -r lib/ $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df

  deploy_image_builder_buildkitd:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: image-builder-buildkit
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: utility-containers/image-builder-buildkit
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df

  deploy_image_puller:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
          REGISTRY: dadosfera
          REPOSITORY: image-puller
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: utility-containers/image-puller
        run: |
          cp .dockerignore $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/Dockerfile $BUILD_CTX
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df

  deploy_jupyter_enterprise_gateway:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: jupyter-enterprise-gateway
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: services/jupyter-enterprise-gateway
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          cp -r lib/ $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df

  deploy_base_kernel_py:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: base-kernel-py
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: services/base-images
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          cp -r lib/ $BUILD_CTX
          cp -r orchest-sdk/ $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/base-kernel-py/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df

  deploy_base_kernel_r:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: base-kernel-r
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: services/base-images
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          cp -r lib/ $BUILD_CTX
          cp -r orchest-sdk/ $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/base-kernel-r/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df

  deploy_base_kernel_julia:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: base-kernel-julia
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: services/base-images
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          cp -r lib/ $BUILD_CTX
          cp -r orchest-sdk/ $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/base-kernel-julia/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df

  deploy_base_kernel_javascript:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: base-kernel-javascript
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: services/base-images
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          cp -r lib/ $BUILD_CTX
          cp -r orchest-sdk/ $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/base-kernel-javascript/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df

  deploy_session_sidecar:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: session-sidecar
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: services/session-sidecar
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          cp -r lib/ $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df

  deploy_image_builder_buildx:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: image-builder-buildx
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: utility-containers/image-builder-buildx
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df

  deploy_buildkit_daemon:
    needs: [calver_release, extract_environment]
    runs-on: ubuntu-latest
    environment: prd
    if: ${{ needs.calver_release.outputs.new_release_published == 'true' }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Login to AWS ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Image to Dockerhub
        env:
          REGISTRY: dadosfera
          REPOSITORY: buildkit-daemon
          IMAGE_TAG: ${{ needs.calver_release.outputs.new_release_version }}
          BUILD_CTX: services/buildkit-daemon
          ECR_REGISTRY: ${{ steps.login_ecr.outputs.registry }}
          ECR_REGISTRY_ALIAS: u5k1d2l0
        run: |
          cp .dockerignore $BUILD_CTX
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG --build-arg ORCHEST_VERSION=$IMAGE_TAG -f $BUILD_CTX/Dockerfile $BUILD_CTX
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG

      - name: Cleanup Docker's Leftovers
        if: always()
        continue-on-error: true
        run: |
          docker system prune --volumes -a -f
          docker system df
